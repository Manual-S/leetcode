# æ•°ç»„å’ŒçŸ©é˜µ

## [1.ä¸¤æ•°ä¹‹å’Œ](https://leetcode-cn.com/problems/two-sum/)
```c++
class Solution 
{
public:
    vector<int> twoSum(vector<int>& nums, int target) 
    {
        vector<int> ans;
        unordered_map<int,int> m;

        for(int i = 0;i < nums.size();i++)
        {
            int res = target - nums[i];
            if(m.find(res) != m.end())
            {
                //è¯´æ˜æ‰¾åˆ°äº†ç­”æ¡ˆ
                ans.push_back(m[res]);
                ans.push_back(i);
                break;
            }

            m[nums[i]] = i;
        }

        return ans;        
    }
};
```
## [31. ä¸‹ä¸€ä¸ªæ’åˆ—](https://leetcode-cn.com/problems/next-permutation/)
```c++
class Solution 
{
public:
    void nextPermutation(vector<int>& nums) 
    {
        int len = nums.size();
        int i = 0;
        //ä»åå‘å‰æ‰¾ç¬¬ä¸€ä¸ªå‡åºå¯¹
        for(i = len - 2;i >= 0;i--)
        {
            if(nums[i] < nums[i + 1])
            {
                break;
            }
        }
        
        if(i == -1)
        {
            //è¯¥åºåˆ—æœ¬èº«å°±æ˜¯ä¸€ä¸ªä¸¥æ ¼é™åºåºåˆ—
            reverse(nums.begin(),nums.end());
            return;
        }

        //ä»åå‘å‰æ‰¾ç¬¬ä¸€ä¸ªå¤§äºnums[i]çš„æ•°
        for(int j = len - 1;j >= i + 1;j--)
        {
            if(nums[j] > nums[i])
            {
                //æ‰¾åˆ°äº†è¿™æ ·ä¸€ä¸ªnums[j];
                std::swap(nums[j],nums[i]);
                reverse(nums.begin() + i + 1,nums.end());
                break;
            }
        }

    }
};
```
## [41. ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•°](https://leetcode-cn.com/problems/first-missing-positive/)
```c++
class Solution 
{
public:
    int firstMissingPositive(vector<int>& nums) 
    {
        //å®ç°ä¸€ä¸ªå“ˆå¸Œè¡¨
        //è¿™ä¸ªå“ˆå¸Œè¡¨çš„æ˜ å°„è§„åˆ™æ˜¯
        //æ•°å€¼ä¸ºiçš„æ˜ å°„åˆ°i - 1ä¸‹æ ‡å¤„
        int len = nums.size();
        int i = 0;
        while(i < len)
        {
            if(nums[i] <= 0 || nums[i] > nums.size() || nums[i] == nums[nums[i] - 1])
            {
                //ç‰¹æ®Šçš„å…ƒç´  æ²¡åŠæ³•è¿›è¡Œå“ˆå¸Œæ˜ å°„
                //å·²ç»æ˜ å°„å¥½çš„å…ƒç´  ä¸ç”¨å†æ˜ å°„
                i++;
                continue;
            }
            if(nums[i] != i + 1)
            {
                //è¿›è¡Œå“ˆå¸Œæ˜ å°„
                swap(nums[i],nums[nums[i] - 1]);
            }
        }

        for(int i = 0;i < len;i++)
        {
            if(nums[i] != i + 1)
            {
                //æ‰¾åˆ°äº†æ•°ç»„ä¸­æ²¡æœ‰å‡ºç°çš„æœ€å°çš„æ­£æ•´æ•°
                return i + 1;
            }
        }

        return nums.size() + 1;        
    }
};
```
## [48. æ—‹è½¬å›¾åƒ](https://leetcode-cn.com/problems/rotate-image/)
```c++
class Solution 
{
public:
    void rotate(vector<vector<int>>& matrix) 
    {
        int row = matrix.size();
        int col = matrix[0].size();

        int a = 0;
        int b = 0;
        int c = row - 1;
        int d = col - 1;

        while(a < c && b < d)
        {
            printmatrix(a,b,c,d,matrix);
            a++;
            b++;
            c--;
            d--;
        }        
    }
private:
    void printmatrix(int a,int b,int c,int d,vector<vector<int>>& matrix)
    {
        int num = c - a; //æ—‹è½¬æ¬¡æ•°

        for(int i = 0;i < num;i++)
        {
            int temp = matrix[a + i][d];

            matrix[a + i][d] = matrix[a][b + i];

            matrix[a][b + i] = matrix[c - i][b];

            matrix[c - i][b] = matrix[c][d - i];

            matrix[c][d - i] = temp;
        }
    }
};
```
## [53. æœ€å¤§å­åºå’Œ](https://leetcode-cn.com/problems/maximum-subarray/)
  ğŸˆ è¿™æ˜¯ä¸€é“åŠ¨æ€è§„åˆ’ç±»é¢˜ç›®ï¼Œæ‰€ä»¥ç¬¬ä¸€ä¸ªæƒ³åˆ°çš„æ€è·¯æ˜¯åŠ¨æ€è§„åˆ’ã€‚
```c++
class Solution 
{
public:
    int maxSubArray(vector<int>& nums) 
    {
        int len = nums.size();
        vector<int> dp(len,0);
        dp[0] = nums[0];

        for(int i = 1;i < len;i++)
        {
            dp[i] = dp[i - 1] > 0 ? dp[i - 1] + nums[i] : nums[i];
        }

        return *max_element(dp.begin(),dp.end());
    }
};
```
## [54. èºæ—‹çŸ©é˜µ](https://leetcode-cn.com/problems/spiral-matrix/)
```c++
class Solution 
{
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) 
    {
        if(matrix.empty())
        {
            return {};
        }
        int row = matrix.size();
        int col = matrix[0].size();

        int a = 0;
        int b = 0;
        int c = row - 1;
        int d = col - 1;
        vector<int> ans;
        
        while(a <= c && b <= d)
        {
            printmatrix(a,b,c,d,matrix,ans);
            a++;
            b++;
            c--;
            d--;
        }

        return ans;
    }
private:
    void printmatrix(const int& a,const int& b,const int& c,const int& d,vector<vector<int>>& matrix,vector<int>& ans)
    {
        int sx = a;
        int sy = b;
        int ex = c;
        int ey = d;

        if(sx == ex)
        {
            //è¡Œå·ç›¸ç­‰
            while(sy <= ey)
            {
                ans.push_back(matrix[sx][sy]);
                sy++;
            }
            return;
        }

        if(sy == ey)
        {
            //ä¸€åˆ—
            while(sx <= ex)
            {
                ans.push_back(matrix[sx][sy]);
                sx++;
            }
            return;
        }

        //ä¸æ˜¯ä¸€è¡Œæˆ–è€…ä¸€åˆ—çš„æƒ…å†µ
        while(sy < ey)
        {
            ans.push_back(matrix[sx][sy]);
            sy++;
        }

        while(sx < ex)
        {
            ans.push_back(matrix[sx][sy]);
            sx++;
        }

        while(sy > a)
        {
            ans.push_back(matrix[sx][sy]);
            sy--;
        }

        while(sx > b)
        {
            ans.push_back(matrix[sx][sy]);
            sx--;
        }
    }
};
```
## [55. è·³è·ƒæ¸¸æˆ](https://leetcode-cn.com/problems/jump-game/)
  è´ªå¿ƒæ€è·¯ã€‚
```c++
class Solution 
{
public:
    bool canJump(vector<int>& nums) 
    {
        int mostright = 0;

        for(int i = 0;i < nums.size();i++)
        {
            if(i <= mostright)
            {
                //mostrightå·¦è¾¹çš„iéƒ½æ˜¯å¯è¾¾çš„
                mostright = std::max(mostright,nums[i] + i);
                if(mostright >= nums.size() - 1)
                {
                    return true;
                }
            }
        }

        return false;
    }
};
```
## [56. åˆå¹¶åŒºé—´](https://leetcode-cn.com/problems/merge-intervals/)

```c++
bool myfunc(const vector<int>& a,const vector<int>& b)
{
    return a[0] < b[0];
}

class Solution 
{
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) 
    {
        if(intervals.empty())
        {
            return {};
        }
        sort(intervals.begin(),intervals.end(),myfunc);
        int len = intervals.size();
        vector<vector<int>> ans;
        ans.push_back(intervals[0]);
       
        for(int i = 1;i < len;i++)
        {
            int l = intervals[i][0];
            int r = intervals[i][1];
            if(ans.back()[1] < l)
            {
                //æ’å…¥æ–°åŒºé—´
                ans.push_back(intervals[i]);
            }
            else
            {
                //ä¸æ’å…¥æ–°åŒºé—´ ä½†æ˜¯è¦è€ƒå¯Ÿræ›´å¤§ è¿˜æ˜¯ans.back()[1]æ›´å¤§
                ans.back()[1] = std::max(r,ans.back()[1]);
            }
        }

        return ans;
    }
};
```
## [57. æ’å…¥åŒºé—´](https://leetcode-cn.com/problems/insert-interval/)
```c++
class Solution {
public:
	vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {

		auto it = intervals.begin();
		
		while (it != intervals.end() &&  it->at(0) < newInterval[0])
		{
			
			it++;
		}

		intervals.insert(it, newInterval);

		//åšåŒºé—´åˆå¹¶è¿‡ç¨‹
		int len = intervals.size();
		vector<vector<int>> ans;
		ans.push_back(intervals[0]);

		for (int i = 1; i < len; i++)
		{
			int l = intervals[i][0];
			int r = intervals[i][1];
			if (ans.back()[1] < l)
			{
				//æ’å…¥æ–°åŒºé—´
				ans.push_back(intervals[i]);
			}
			else
			{
				//ä¸æ’å…¥æ–°åŒºé—´ ä½†æ˜¯è¦è€ƒå¯Ÿræ›´å¤§ è¿˜æ˜¯ans.back()[1]æ›´å¤§
				ans.back()[1] = std::max(r, ans.back()[1]);
			}
		}

		return ans;
	}
};
```
## [59. èºæ—‹çŸ©é˜µ II](https://leetcode-cn.com/problems/spiral-matrix-ii/)
```c++
class Solution 
{
public:
    vector<vector<int>> generateMatrix(int n) 
    {
        int a = 0;
        int b = 0;
        int c = n - 1;
        int d = n - 1;
        vector<vector<int>> matrix(n,vector<int>(n));
        int count = 1;
        while(a <= c && b <= d)
        {
            build(a,b,c,d,matrix,count);
            a++;
            b++;
            c--;
            d--;
        }
        return matrix;
    }
private:
    void build(const int& a,const int& b,const int& c,const int& d, vector<vector<int>>& matrix,int& n)
    {
        int sx = a;
        int sy = b;
        int ex = c;
        int ey = d;

        if(sx == ex && sy == ey)
        {
            matrix[sx][sy] = n;
        }
        while(sy < ey)
        {
            matrix[sx][sy] = n;
            n++;
            sy++;
        }

        while(sx < ex)
        {
            //ans.push_back(matrix[sx][sy]);
            matrix[sx][sy] = n;
            n++;
            sx++;
        }

        while(sy > a)
        {
            //ans.push_back(matrix[sx][sy]);
            matrix[sx][sy] = n;
            n++;
            sy--;
        }

        while(sx > b)
        {
            //ans.push_back(matrix[sx][sy]);
            matrix[sx][sy] = n;
            n++;
            sx--;
        }
    }
};
```
## [66. åŠ ä¸€](https://leetcode-cn.com/problems/plus-one/)
```c++
class Solution 
{
public:
    vector<int> plusOne(vector<int>& digits) 
    {
        int len = digits.size();
        int carry = 0;
        digits[len - 1] = digits[len - 1] + 1;
        for(int i = len - 1;i >= 0;i--)
        {
            int sum = digits[i] + carry;
            digits[i] = sum % 10;
            carry = sum / 10;
            if(carry == 0)
            {
                break;
            }
        }

        if(carry != 0)
        {
            digits.insert(digits.begin(),carry);
        }

        return digits;   
    }
};
```
## [73. çŸ©é˜µç½®é›¶](https://leetcode-cn.com/problems/set-matrix-zeroes/)
  åšåˆ°é¢å¤–ç©ºé—´å¤æ‚åº¦ä¸º`O(1)`ã€‚
```c++
class Solution 
{
public:
    void setZeroes(vector<vector<int>>& matrix) 
    {
        bool zerocol = false;
        int row = matrix.size();
        int col = matrix[0].size();

        for(int i = 0;i < row;i++)
        {
            for(int j = 0;j < col;j++)
            {
                if(matrix[i][j] == 0)
                {
                    if(j == 0)
                    {
                        zerocol= true;
                        //continue;
                    }
                    matrix[0][j] = 0;
                    matrix[i][0] = 0;
                }
            }
        }

        for(int i = 1;i < row;i++)
        {
            for(int j = 1;j < col;j++)
            {
                if(matrix[i][0] == 0 || matrix[0][j] == 0)
                {
                    matrix[i][j] = 0;
                }
            }
        }

        //ç¬¬ä¸€è¡Œè¢«æ ‡è®°äº†
        if(matrix[0][0] == 0)
        {
            for(int j = 0;j < col;j++)
            {
                matrix[0][j] = 0;
            }
        }
        if(zerocol)
        {
            //ç¬¬0åˆ—ä¹Ÿè¦å˜æˆ0
            for(int i = 0;i < row;i++)
            {
                matrix[i][0] = 0;
            }
        }
    }
};
```
## [118. æ¨è¾‰ä¸‰è§’](https://leetcode-cn.com/problems/pascals-triangle/)
```c++
class Solution 
{
public:
    vector<vector<int>> generate(int numRows) 
    {
        if(numRows == 0)
        {
            return {};
        }
        vector<vector<int>> ans;
        vector<int> cur{1};  //ç¬¬ä¸€è¡Œ
        ans.push_back(cur);

        for(int i = 1;i < numRows;i++)
        {
            cur.clear();
            for(int j = 0;j < i + 1;j++)
            {
                if(j == 0 || j == i)
                {
                    cur.push_back(1);
                    continue;
                }
                cur.push_back(ans[i - 1][j - 1] + ans[i - 1][j]);
            }
            ans.push_back(cur);
        }

        return ans;        
    }
};
```
## [119. æ¨è¾‰ä¸‰è§’ II](https://leetcode-cn.com/problems/pascals-triangle-ii/)
```c++
class Solution 
{
public:
    vector<int> getRow(int rowIndex) 
    {
        //ä¸ç”¨å…¬å¼æ³• 
        //è¿™é‡Œä¸€ä¸ªèŠ‚çœç©ºé—´çš„æ€è·¯æ˜¯
        //ç®—ç¬¬kè¡Œçš„ç»“æœ åªéœ€è¦k - 1è¡Œå³å¯
        vector<int> pre;
        vector<int> cur; 

        for(int i = 0;i <= rowIndex;i++)
        {
            cur.clear();
            for(int j = 0;j < i + 1;j++)
            {
                if(j == 0 || j == i)
                {
                    cur.push_back(1);
                    continue;
                }
                cur.push_back(pre[j - 1] + pre[j]);
            }
            pre = cur;
        }

        return cur;     
    }
};
```
## [120. ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ](https://leetcode-cn.com/problems/triangle/)
```c++
class Solution 
{
public:
    int minimumTotal(vector<vector<int>>& triangle) 
    {
        if(triangle.empty())
        {
            return 0;
        }
        int row = triangle.size();
        int col = triangle[row - 1].size();
        
        vector<vector<int>> dp(row,vector<int>(col));

        //åˆå§‹åŒ–æœ€åä¸€åˆ—
        for(int j = 0;j < col;j++)
        {
            dp[row - 1][j] = triangle[row - 1][j]; 
        }

        //å¼€å§‹åŠ¨æ€è§„åˆ’è¿‡ç¨‹
        for(int i = row - 2;i >= 0;i--)
        {
            for(int j = 0;j < triangle[i].size();j++)
            {
                dp[i][j] = std::min(dp[i + 1][j],dp[i + 1][j + 1]) + triangle[i][j]; 
            }
        }

        return dp[0][0];
    }
};
```
## [128. æœ€é•¿è¿ç»­åºåˆ—](https://leetcode-cn.com/problems/longest-consecutive-sequence/)
  æ—¶é—´å¤æ‚åº¦ä¸º`O(n^2)`çš„è§£æ³•ã€‚è¶…æ—¶ã€‚
```c++
class Solution 
{
public:
    int longestConsecutive(vector<int>& nums) 
    {
        unordered_set<int> m;
        int len = nums.size();
        int longest = 0;

        for(auto i : nums)
        {
            m.insert(i);  //å»é‡ åŒæ—¶å°†æŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦é™ä½åˆ°O(1)
        }

        for(int i = 0;i < len;i++)
        {
            int count = 0;
            int temp = nums[i];

            while(m.count(temp))
            {
                count++;
                temp++;
            }

            longest = std::max(longest,count);
            count = 0;
        }

        return longest;
    }
};
```
  æ—¶é—´å¤æ‚åº¦ä¸º`O(n)`çš„è§£æ³•ã€‚
```c++
class Solution 
{
public:
    int longestConsecutive(vector<int>& nums) 
    {
        unordered_set<int> m;
        int len = nums.size();
        int longest = 0;

        for(auto i : nums)
        {
            m.insert(i);  //å»é‡ åŒæ—¶å°†æŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦é™ä½åˆ°O(1)
        }

        for(int i = 0;i < len;i++)
        {
            int count = 0;
            int temp = nums[i];

            if(!m.count(temp - 1))
            {
                //å¦‚æœå­˜åœ¨x - 1è¿™ç§æƒ…å†µ å‰ªæ
                //ä¸å­˜åœ¨ æ‰æ‰§è¡Œ
                count = 1;
                while(m.count(temp + 1))
                {
                    temp++;
                    count++;
                }
            }

            longest = std::max(count,longest);
        }

        return longest;
    }
};
```
## [152. ä¹˜ç§¯æœ€å¤§å­æ•°ç»„](https://leetcode-cn.com/problems/maximum-product-subarray/)
  DPé¢˜ç›®ã€‚
```c++
class Solution 
{
public:
    int maxProduct(vector<int>& nums) 
    {
        int len = nums.size();

        vector<int> maxvalue(len);
        vector<int> minvalue(len);

        maxvalue[0] = nums[0];
        minvalue[0] = nums[0];

        for(int i = 1;i < len;i++)
        {
            int temp1 = nums[i] * maxvalue[i - 1];
            int temp2 = nums[i] * minvalue[i - 1];

            maxvalue[i] = std::max(temp1,std::max(temp2,nums[i]));
            minvalue[i] = std::min(temp1,std::min(temp2,nums[i]));
        }

        return *std::max_element(maxvalue.begin(),maxvalue.end());
    }
};
```
## [169. å¤šæ•°å…ƒç´ ](https://leetcode-cn.com/problems/majority-element/)
  æ’åºåšæ³•ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º`O(nlogn)`ã€‚
```c++
class Solution 
{
public:
    int majorityElement(vector<int>& nums) 
    {
        sort(nums.begin(),nums.end());

        return nums[nums.size() / 2];
    }
};
```
  å“ˆå¸Œè¡¨ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º`O(n)`ã€‚
```c++
class Solution 
{
public:
    int majorityElement(vector<int>& nums) 
    {
        unordered_map<int,int> m;
        int cnt = 0;
        int ans = 0;

        for(int i = 0;i < nums.size();i++)
        {
            m[nums[i]]++;
            if(m[nums[i]] > cnt)
            {
                cnt = m[nums[i]];
                ans = nums[i];
            }
        }

        return ans;
    }
};
```
  åˆ†æ²»åšæ³•ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º`O(nlogn)`ã€‚
```c++
class Solution 
{
public:
    int majorityElement(vector<int>& nums) 
    {
        return getmajority(0,nums.size() - 1,nums);
    }
private:
    int countinrange(int left,int right,vector<int>& nums,const int& target)
    {
        int count = 0;
        for(int i = left;i <= right;i++)
        {
            if(nums[i] == target)
            {
                count++;
            }
        }

        return count;
    }
    int getmajority(int left,int right,vector<int>& nums)
    {
        if(left == right)
        {
            //æ•°ç»„ä¸­åªæœ‰ä¸€ä¸ªæ•°
            //åˆ™è¿™ä¸ªæ•°å¿…ç„¶æ˜¯ä¼—æ•°
            return nums[left];
        }

        int middle = left + (right - left) / 2;
        int leftmaj = getmajority(left,middle,nums);
        int rightmaj = getmajority(middle + 1,right,nums);

        if(leftmaj == rightmaj)
        {
            //å·¦è¾¹çš„ä¼—æ•°å’Œå³è¾¹çš„ä¼—æ•°ç›¸ç­‰
            //è¯´æ˜[left,right]åŒºé—´ä¸Šçš„ä¼—æ•°å°±æ˜¯leftmaj
            return leftmaj;
        }

        //ä¸ç›¸ç­‰
        int leftcount = countinrange(left,middle,nums,leftmaj);
        int rightcount = countinrange(middle + 1,right,nums,rightmaj);

        return leftcount > rightcount ? leftmaj : rightmaj;
    }
};
```
  æŠ•ç¥¨ç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º`O(n)`ï¼Œé¢å¤–ç©ºé—´å¤æ‚åº¦ä¸º`O(1)`ã€‚
```c++
class Solution 
{
public:
    int majorityElement(vector<int>& nums) 
    {
        int can = -1;
        int count = 0;

        for(auto i : nums)
        {
            if(can == i)
            {
                count++;
            }
            else
            {
                count--;
                if(count < 0)
                {
                    can = i;
                    count = 1;
                }
            }
        }

        return can;
    }
};
```
## [289. ç”Ÿå‘½æ¸¸æˆ](https://leetcode-cn.com/problems/game-of-life/)
```c++
class Solution 
{
public:
    void gameOfLife(vector<vector<int>>& board) 
    {
        if(board.empty())
        {
            return;
        }
        int row = board.size();
        int col = board[0].size();

        int dx[] = {-1,1,0,0,-1,1,-1,1};
        int dy[] = {0,0,-1,1,-1,-1,1,1};  //ä¸Š ä¸‹ å·¦ å³ å·¦ä¸Š å·¦ä¸‹ å³ä¸Š å³ä¸‹

        for(int i = 0;i < row;i++)
        {
            for(int j = 0;j < col;j++)
            {
                int count = 0;  //è®°å½•8ä¸ªæ–¹å‘ä¸Šç»†èƒçš„ä¸ªæ•°
                for(int step = 0;step < 8;step++)
                {
                    int tx = i + dx[step];
                    int ty = j + dy[step];

                    if(tx < 0 || ty < 0 || tx >= row || ty >= col || board[tx][ty] == 0 || board[tx][ty] == 2)
                    {
                        continue;
                    }
                    count++;
                }

                if(board[i][j] == 1)
                {
                    //æœ¬èº«æ˜¯æ´»ç»†èƒ åªèƒ½ç»§ç»­å­˜æ´» æˆ– æ­»äº¡
                    if(count < 2 || count > 3)
                    {
                        board[i][j] = -1;
                    }
                }
                else if(board[i][j] == 0)
                {
                    //æœ¬èº«æ˜¯æ­»ç»†èƒ åªèƒ½ç»§ç»­æ­»äº¡ æˆ– å¤æ´»
                    if(count == 3)
                    {
                        board[i][j] = 2;
                    }
                }
            }
        }

        //ç»“ç®—
        for(int i = 0;i < row;i++)
        {
            for(int j = 0;j < col;j++)
            {
                if(board[i][j] == 2)
                {
                    //æœ¬æ¥æ˜¯æ­»ç»†èƒ å˜æˆäº†æ´»ç»†èƒ
                    board[i][j] = 1;
                }
                else if(board[i][j] == -1)
                {
                    //æœ¬æ¥æ˜¯æ´»ç»†èƒ å˜æˆäº†æ­»ç»†èƒ
                    board[i][j] = 0;
                }
            }
        }
    }
};
```
## [560. å’Œä¸ºKçš„å­æ•°ç»„](https://leetcode-cn.com/problems/subarray-sum-equals-k/)
  æš´åŠ›è§£æ³•ï¼Œå±…ç„¶èƒ½è¿‡OJã€‚
```c++
class Solution 
{
public:
    int subarraySum(vector<int>& nums,const int& k) 
    {
        int len = nums.size();
        int count = 0;
        int sum = 0;
        for(int i = 0;i < len;i++)
        {
            sum = sum + nums[i];
            if(sum == k)
            {
                count++;
            }
            
            for(int j = i + 1;j < len;j++)
            {
                sum = sum + nums[j];
                if(sum == k)
                {
                    count++;
                }
            }

            sum = 0;
        }

        return count;
    }
};
```
  å‰ç¼€å’Œï¼Œæ—¶é—´å¤æ‚åº¦ä¸º`O(n^2)`ã€‚å±…ç„¶æ²¡æœ‰è¿‡OJã€‚ğŸ˜‚
```c++
class Solution 
{
public:
    int subarraySum(vector<int>& nums,const int& k) 
    {
        //å‰ç¼€å’Œè§£æ³•
        int len = nums.size();
        vector<int> pre(len);
        pre[0] = nums[0];
        for(int i = 1;i < len;i++)
        {
            pre[i] = pre[i - 1] + nums[i];
        }
        int count = 0;

        for(int left = 0;left < len;left++)
        {
            for(int right = left;right < len;right++)
            {
                if(left == 0)
                {
                    if(pre[right] == k)
                    {
                        count++;
                    }
                    continue;
                }

                if(pre[right] - pre[left - 1] == k)
                {
                    count++;
                }
            }
        }

        return count;
    }
};
```
  å‰ç¼€å’Œ+å“ˆå¸Œè¡¨ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º`O(n)`ã€‚
```c++
class Solution 
{
public:
    int subarraySum(vector<int>& nums,const int k) 
    {
        unordered_map<int,int> m; //key ä»£è¡¨å‰ç¼€å’Œ valueä»£è¡¨å‡ºç°æ¬¡æ•°
        m[0] = 1;  //å‰ç¼€å’Œä¸º0çš„å‡ºç°äº†ä¸€æ¬¡

        int len = nums.size();
        int count = 0;
        int pre = 0;

        for(int i = 0;i < len;i++)
        {
            pre = pre + nums[i];        
            if(m.find(pre - k) != m.end())
            {
                count = count + m[pre - k];
            }
            m[pre]++;
        }

        return count;
    }
};
```
## [914. å¡ç‰Œåˆ†ç»„](https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/)
```c++
class Solution {
public:
    bool hasGroupsSizeX(vector<int>& deck) 
    {
        for(auto i : deck)
        {
            count[i]++;
        }

        //ä¸‹é¢æ˜¯æ±‚æœ€å¤§å…¬çº¦æ•°
        int g = 0;
        for(auto i : count)
        {
            if(i == 0)
            {
                continue;
            }
            g = gcd(g,i);
            if(g < 2)
            {
                return false;
            }
        }

        return true;
    }
private:
    int count[10001];
};
```
## [945. ä½¿æ•°ç»„å”¯ä¸€çš„æœ€å°å¢é‡](https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/)
  æ’åºè§£æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º`O(nlogn)`ã€‚
```c++
class Solution 
{
public:
    int minIncrementForUnique(vector<int>& A) 
    {
        int move = 0;
        int len = A.size();
        sort(A.begin(),A.end());

        for(int i = 1;i < len;i++)
        {
            if(A[i - 1] >= A[i])
            {
                int pre = A[i];
                A[i] = A[i - 1] + 1;
                move = move + A[i] - pre;
            }
        }

        return move;
    }
};
```
## [974. å’Œå¯è¢« K æ•´é™¤çš„å­æ•°ç»„](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)
```c++
class Solution
{
public:
	int subarraysDivByK(vector<int>& A, int k)
	{
		int len = A.size();
		unordered_map<int, int> m;  //keyæ˜¯pre[i] % k valueæ˜¯å‡ºç°æ¬¡æ•°
		m[0] = 1;
		int pre = 0;
		int count = 0;

		for (int i = 0; i < len; i++)
		{
			pre = pre + A[i];
			int key = pre % k;
			if (key < 0)
			{
				key = key + k;
			}
			//int key = (pre % k + k) % k;  //è¿™é‡Œæ˜¯C++çš„è¯­è¨€ç‰¹æ€§
			//int key = pre % k;
			if (m.count(key))
			{
				count = m[key] + count;
			}

			m[key]++;
		}
		return count;
	}
};
```
